#!/usr/bin/env python3

import os
import sys

from os import path
from sys import stderr, argv
from subprocess import Popen, PIPE
from shutil import copyfile

from config import configs


def run_cmd(cmd, effect='stdout'):
    '''
    Runs a shell command, waits for it to complete, and returns stdout.
    '''
    print('CMD: %s' % cmd)
    with open('/dev/null', 'w') as dev_null:
        call = Popen(cmd, shell=True, stdout=PIPE, stderr=dev_null)
        ret, _ = call.communicate()
        if effect == 'stdout':
            return ret.decode('utf8')
        else:
            return call.returncode

def main():
    '''
    Build each config, placing the build artifacts in ./bin
    '''
    os.makedirs('./bin', exist_ok=True)
    root_dir = os.getcwd()

    run_cmd('git submodule update --init')

    for config in configs:
        os.chdir(path.join(root_dir, 'redis', 'src'))

        # remove config from older builds
        try:
            os.remove('.make-settings')
        except OSError:
            pass

        if config.ldflags:
            ldflags = "LDFLAGS='%s'" % config.ldflags
        else:
            ldflags = ''

        make_cmd = "make %s %s" % (config.use_flags, ldflags)
        rc = run_cmd(make_cmd + ' clean', effect=None)
        # if rc != 0:
        #     print('make failed')
        #     return

        result = run_cmd('git status')
        if 'working tree clean' not in result:
            print('tree dirty, exiting')
            return

        rc = run_cmd(make_cmd + ' -j4', effect=None)
        # if rc != 0:
        #     print('make failed')
        #     return

        # copy redis-server, redis-cli, redis-benchmark to /bin w/ suffix
        for f in ['redis-server', 'redis-cli', 'redis-benchmark']:
            copyfile(f, path.join(root_dir, 'bin', '%s-%s' % (f, config.name)))
    

if __name__ == '__main__':
    sys.exit(main())
